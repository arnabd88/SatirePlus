
INPUTS {
	a_0_0 fl64 : (0.01,1.0) ;
	a_0_1 fl64 : (0.02,0.1) ;
	a_0_2 fl64 : (2.0,3.1) ;
	a_1_0 fl64 : (2.5,3.5) ;
	a_1_1 fl64 : (4.05,4.15) ;
	a_1_2 fl64 : (4.5, 5.5) ;
	a_2_0 fl64 : (2.01,4.0) ;
	a_2_1 fl64 : (3.02,3.5) ;
	#a_2_2 fl64 : (0.24,0.26) ;
	a_2_2 fl64 : (2.24,5.26) ;

}

OUTPUTS {
	off; #rot_a_2_1 ; #jta_0_0 ; #J_2_2; #rot_a_2_1 ;
	#c ; #J_2_2 ;
	#r ;
}

EXPRS {

	i int = 0 ;
	j int = 0 ;
	n int = 0 ;

	# Fixing a p.q value since it depends on the exact values of the incoming matrix
	p int = 1 ; 
	q int = 2 ;

	v_0_0 = 1.0; v_0_1 = 0.0; v_0_2 = 0.0;
	v_1_0 = 0.0; v_1_1 = 1.0; v_1_2 = 0.0;
	v_2_0 = 0.0; v_2_1 = 0.0; v_2_2 = 1.0;

	# SymSchur2 -> rortation around p,q
	if (( a_1_2 > 0 && a_1_2 > 0.0001 ) || ( a_1_2 < 0 && -1*a_1_2 > 0.0001)) then
		
		r = (a_2_2 - a_1_1) / (2.0 * a_1_2) ;

		if ( r >= 0.0 ) then
			t = 1.0 / ( r + sqrt(1.0 + r*r));
		else
			t = -1*(1.0 / (sqrt(1.0 + r*r) - r));
		endif

		c = 1.0 / (sqrt(1.0 + t*t)) ;
		s = t * c ;
	else
		c = 1.0 ;
		s = 0.0 ;
	endif

	J_0_0 = 1.0;
	J_0_1 = 0.0;
	J_0_2 = 0.0;
	J_1_0 = 0.0;
	J_1_1 = 1.0;
	J_1_2 = 0.0;
	J_2_0 = 0.0;
	J_2_1 = 0.0;
	J_2_2 = 1.0;

	J_1_1 = c ;
	J_1_2 = s ;
	J_2_1 = -1*s ;
	J_2_2 = c ;

	# vl = v * J
	v_0_0 = v_0_0 * J_0_0 + v_0_1 * J_1_0 + v_0_2 * J_2_0 ;
	v_0_1 = v_0_0 * J_0_1 + v_0_1 * J_1_1 + v_0_2 * J_2_1 ;
	v_0_2 = v_0_0 * J_0_2 + v_0_1 * J_1_2 + v_0_2 * J_2_2 ;
	v_1_0 = v_1_0 * J_0_0 + v_1_1 * J_1_0 + v_1_2 * J_2_0 ;
	v_1_1 = v_1_0 * J_0_1 + v_1_1 * J_1_1 + v_1_2 * J_2_1 ;
	v_1_2 = v_1_0 * J_0_2 + v_1_1 * J_1_2 + v_1_2 * J_2_2 ;
	v_2_0 = v_2_0 * J_0_0 + v_2_1 * J_1_0 + v_2_2 * J_2_0 ;
	v_2_1 = v_2_0 * J_0_1 + v_2_1 * J_1_1 + v_2_2 * J_2_1 ;
	v_2_2 = v_2_0 * J_0_2 + v_2_1 * J_1_2 + v_2_2 * J_2_2 ;

	# jta = (J.transpose() * a)
	jta_0_0 = J_0_0 * a_0_0 + J_1_0 * a_1_0 + J_2_0 * a_2_0 ;
	jta_0_1 = J_0_0 * a_0_1 + J_1_0 * a_1_1 + J_2_0 * a_2_1 ;
	jta_0_2 = J_0_0 * a_0_2 + J_1_0 * a_1_2 + J_2_0 * a_2_2 ;
	jta_1_0 = J_0_1 * a_0_0 + J_1_1 * a_1_0 + J_2_1 * a_2_0 ;
	jta_1_1 = J_0_1 * a_0_1 + J_1_1 * a_1_1 + J_2_1 * a_2_1 ;
	jta_1_2 = J_0_1 * a_0_2 + J_1_1 * a_1_2 + J_2_1 * a_2_2 ;
	jta_2_0 = J_0_2 * a_0_0 + J_1_2 * a_1_0 + J_2_2 * a_2_0 ;
	jta_2_1 = J_0_2 * a_0_1 + J_1_2 * a_1_1 + J_2_2 * a_2_1 ;
	jta_2_2 = J_0_2 * a_0_2 + J_1_2 * a_1_2 + J_2_2 * a_2_2 ;

	## rot_a = jta * J
	rot_a_0_0 = jta_0_0 * J_0_0 + jta_0_1 * J_1_0 + jta_0_2 * J_2_0 ;
	rot_a_0_1 = jta_0_0 * J_0_1 + jta_0_1 * J_1_1 + jta_0_2 * J_2_1 ;
	rot_a_0_2 = jta_0_0 * J_0_2 + jta_0_1 * J_1_2 + jta_0_2 * J_2_2 ;
	rot_a_1_0 = jta_1_0 * J_0_0 + jta_1_1 * J_1_0 + jta_1_2 * J_2_0 ;
	rot_a_1_1 = jta_1_0 * J_0_1 + jta_1_1 * J_1_1 + jta_1_2 * J_2_1 ;
	rot_a_1_2 = jta_1_0 * J_0_2 + jta_1_1 * J_1_2 + jta_1_2 * J_2_2 ;
	rot_a_2_0 = jta_2_0 * J_0_0 + jta_2_1 * J_1_0 + jta_2_2 * J_2_0 ;
	rot_a_2_1 = jta_2_0 * J_0_1 + jta_2_1 * J_1_1 + jta_2_2 * J_2_1 ;
	rot_a_2_2 = jta_2_0 * J_0_2 + jta_2_1 * J_1_2 + jta_2_2 * J_2_2 ;

	#off = 0.0 ;

	### Compute the norm of off-diagonal elements
	off = rot_a_0_1 * rot_a_0_1 + rot_a_0_2 * rot_a_0_2 + rot_a_1_0 * rot_a_1_0 + rot_a_1_2 * rot_a_1_2 + rot_a_2_0 * rot_a_2_0 + rot_a_2_1 * rot_a_2_1 ;
}
