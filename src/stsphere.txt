## Given Sphere s and Point p, update s (if needed) to just encompass p
##-------------
## pseducode  ||
##-------------
## struct Sphere { Point c ; float r; }
## struct Point { float x; float y; float z;}
## void SphereOfSphereAndPt(Sphere &s, Point &p)
## {
## 	Vector d = p - s.c ;     // [dx,dy,dz] = [px-cx, py-cy, pz-cz]
## 	float dist2 = Dot(d,d);  // dist2 = dx*dx + dy*dy + dz*dz
## 
## 	if (dist2 > s.r * s.r) {   
## 		float dist = Sqrt(dist2);
## 		float newRadius = (s.r + dist) * 0.5f ;
## 		float k = (newRadius - s.r) / dist ;
## 		s.r = newRadius ;
## 		s.c += d*k;
## 	}
## }

INPUTS {
	px0 fl64 : (0.5, 1.5)	;
	py0 fl64 : (0.5, 1.5)	;
	pz0 fl64 : (0.5, 1.5)	;
	px1 fl64 : (0.5, 1.5)	;
	py1 fl64 : (0.5, 1.5)	;
	pz1 fl64 : (0.5, 1.5)	;
	px2 fl64 : (0.5, 1.5)	;
	py2 fl64 : (0.5, 1.5)	;
	pz2 fl64 : (0.5, 1.5)	;
	cx0 fl64 : (5.5, 6.5)	;
	cy0 fl64 : (4.5, 6.5)	;
	cz0 fl64 : (6.5, 7.0)	;
}

OUTPUTS {
	#newRadius ; dist2 ;
	#new_cx ; new_cy ; new_cz ;
	dist1; #radius1 ;
}

EXPRS {
	radius rnd64 = 2.5 ;
	cx rnd64 = cx0 ;
	cy rnd64 = cy0 ;
	cz rnd64 = cz0 ;

	##
	dx rnd64 = px0 - cx ;
	dy rnd64 = py0 - cy ;
	dz rnd64 = pz0 - cz ;

	dist2 rnd64 = dx*dx + dy*dy + dz*dz ;

	dist rnd64 = sqrt(dist2) ;
	newRadius rnd64 = (radius + dist) + 0.5 ;
	k rnd64 = (newRadius - radius)/dist ;
	cx1 rnd64 = cx + dx*k ;
	cy1 rnd64 = cy + dy*k ;
	cz1 rnd64 = cz + dz*k ;
	radius1 rnd64 = newRadius ;

	##
	dx1 rnd64 = px1 - cx1 ;
	dy1 rnd64 = py1 - cy1 ;
	dz1 rnd64 = pz1 - cz1 ;

	dist21 rnd64 = dx1*dx1 + dy1*dy1 + dz1*dz1 ;

		dist1 rnd64 = sqrt(dist21) ;
		newRadius1 rnd64 = (radius1 + dist1) + 0.5 ;
		k1 rnd64 = (newRadius1 - radius1)/dist1 ;
		cx2 rnd64 = cx1 + dx1*k1 ;
		cy2 rnd64 = cy1 + dy1*k1 ;
		cz2 rnd64 = cz1 + dz1*k1 ;
		radius2 rnd64 = newRadius1 ;

}
